## 对比算法概述

用于评估的基准算法涵盖了多种经典的缓存策略，包括 LRU、FIFO、ARC、TwoQ、SIEVE、LFU 以及 S3-FIFO。为确保公平性与可复现性，所有算法均使用 LibCacheSim 框架的 C++ 实现版本，并使用其默认配置或原始论文中给出的推荐参数。

FIFO 内部维护一个由双向链表构成的队列。在遇到新元素时，FIFO 将其插入至队列头部；而对于再次访问命中的元素，FIFO 不改变其在队列中的位置。在缓存已满时，FIFO 直接驱逐位于队尾的元素。

LRU 同样维护一个由双向链表构成的队列。与 FIFO 不同的是，在查询命中或遇到新元素时，LRU 均将其插入至队列头部，即更新最近访问的对象。在缓存已满时，LRU 通过 Belady 最优算法近似驱逐最久未访问的元素。

ARC 采取了两个主缓存列表搭配两个历史记录列表的实现方案。主缓存列表 L1 追踪最近访问的元素（LRU），初始容量为 0；L2 追踪最频繁访问的元素（LFU）。L1 / L2 Ghost 列表分别为对应主缓存列表驱逐元素的历史记录。ARC 通过比较两个历史记录的命中情况，动态调整 L1 和 L2 的容量比例，从而自动适应访问模式的变化。

TwoQ 使用三个由双向链表构成的 FIFO 队列，其中 Ain 存放首次访问的元素；Aout 存放从 Ain 中驱逐且未被二次访问的元素，若被二次访问则转移至 Am；Am 存放被访问过至少两次的元素。缓存超限时的驱逐只在 Ain 或 Am 的队尾进行，Ain / Aout / Am 的容量比例设置为 1：2：1。

SIEVE 利用一个环形双向链表串起所有缓存元素，通过一个全局指针 pointer 循环扫描它们。对于被重复访问的元素，其 freq 标志逐次递增。在缓存已满时，全局指针 pointer 驱逐本轮扫描探测到的第一个 freq 标志为 0 的元素。

LFU 采取 Windowed TinyLFU 实现方案，内部设置一个占总缓存容量 1% 的 LRU 准入窗口，同时保护新元素与主缓存。若元素在准入窗口驻留时被再次访问，还需要与主缓存尾部的元素进行访问频次比较，通过检测后才能触发转移。

S3-FIFO 同样使用三个由双向链表构成的 FIFO 队列，但采取更加激进的筛选策略，采样队列容量仅限制为总缓存容量的 10%；幽灵队列 Ghost 与主队列 Main 则共同占用余下的 90% 容量，不分别设置容量上限，展现出对（潜在）热点元素更加宽容的态度。