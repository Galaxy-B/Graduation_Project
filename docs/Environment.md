## 实验环境配置

所有实验均在一台配备 AMD Ryzen7-5800H CPU@3.20GHz、16GB RAM、512KB L1 缓存、4.0MB L2 缓存和 16.0MB L3 缓存的机器上进行，操作系统为 Ubuntu 24.04。每个测试重复进行了 12 轮，取平均值得到最终结果。

## FFC 算法配置

**FFC** 的缓存驱逐算法由两个先入先出的逻辑队列 $S$（观察队列）和 $M$（主队列）组成，其中每个队列都是一个携带缓存对象信息，即侵入式的双向链表。

新缓存的条目将首先进入容量较小的队列 $S$ 中，在我们的实现中队列 $S$ 的大小被固定为缓存总容量的 $10\%$。设置此队列的目的在于快速过滤掉那些出现频率极低，无后续关联访问的条目。

如果某个条目在队列内驻留期间被再次访问，该条目对应的访问计数将自增。队列 $S$ 在容量超限触发驱逐时，将访问计数大于 $1$ 的条目转移至主队列 $M$ 中，否则直接丢弃；队列 $M$ 基于访问计数按照类 **clock** 算法进行驱逐，即依次递减队尾条目的访问计数，若计数值降为 $1$ 则直接逐出，否则重新插入队首。为保障算法处理效率，访问计数的值被限制在 $4$ 以下。

当总缓存容量超限时，首先检查队列 $S$ 是否已满，若是则从其队尾条目开始驱逐，该条目或被丢弃或被转移至队列 $M$ 内。确认队列 $S$ 容量未超过限制后，检查队列 $M$ 是否已满，若是则按照上述类 **clock** 算法从其队尾条目开始驱逐。